import { Message } from "../types";

export const mapMessagesToHistory = (messages: Message[]): any[] => {
  return messages.map(m => {
    const parts: any[] = [];
    
    if (m.text) {
      parts.push({ text: m.text });
    }
    
    // Handle Input Assets (User uploaded)
    if (m.inputAsset) {
      const base64Data = m.inputAsset.data.includes(',') 
        ? m.inputAsset.data.split(',')[1] 
        : m.inputAsset.data;
        
      parts.push({ 
        inlineData: { 
          mimeType: m.inputAsset.mimeType, 
          data: base64Data 
        } 
      });
    }
    
    // Handle Generated Images (Model output)
    // Note: Gemini API history typically expects model outputs to be text or function calls.
    // Sending back base64 images generated by the model *as context* can be heavy and sometimes not supported 
    // depending on the exact model version, but 2.5/3.0 usually handle it or ignore it.
    // For safety and token conservation, we might summarize generated assets in text for history 
    // unless it's critical. However, let's try sending it if available for "multimodal memory".
    if (m.image && !m.inputAsset) {
       // We skip sending back the model's own generated images to save context window 
       // and prevent potential confusion unless it's an "edit" workflow.
       // Instead, we ensure the text description "Visual manifest complete" is there.
    }

    return {
      role: m.role,
      parts: parts
    };
  }).filter(msg => msg.parts.length > 0);
};